# 枚举 (Enum)

枚举（Enumeration）是一种值类型，用于定义一组命名的常量。枚举使代码更加可读、类型安全，并且便于维护。在C#中，枚举是定义一组相关常量的最佳方式。

## 1. 枚举的基本概念

### 1.1 什么是枚举

```csharp
// 定义一个表示星期的枚举
public enum DayOfWeek
{
    Sunday,    // 0
    Monday,    // 1
    Tuesday,   // 2
    Wednesday, // 3
    Thursday,  // 4
    Friday,    // 5
    Saturday   // 6
}

// 使用枚举
DayOfWeek today = DayOfWeek.Monday;
Console.WriteLine(today); // 输出: Monday
Console.WriteLine((int)today); // 输出: 1
```

### 1.2 枚举的优势

```csharp
// 不使用枚举的问题代码
public class BadExample
{
    public const int STATUS_PENDING = 0;
    public const int STATUS_APPROVED = 1;
    public const int STATUS_REJECTED = 2;
    
    public void ProcessOrder(int status)
    {
        // 容易出错：可能传入无效值
        if (status == 999) // 编译器不会报错，但逻辑错误
        {
            // ...
        }
    }
}

// 使用枚举的改进代码
public enum OrderStatus
{
    Pending,
    Approved,
    Rejected
}

public class GoodExample
{
    public void ProcessOrder(OrderStatus status)
    {
        // 类型安全：只能传入有效的枚举值
        switch (status)
        {
            case OrderStatus.Pending:
                Console.WriteLine("订单待处理");
                break;
            case OrderStatus.Approved:
                Console.WriteLine("订单已批准");
                break;
            case OrderStatus.Rejected:
                Console.WriteLine("订单已拒绝");
                break;
        }
    }
}
```

## 2. 枚举的声明和定义

### 2.1 基本声明

```csharp
// 简单枚举声明
public enum Color
{
    Red,
    Green,
    Blue
}

// 指定访问修饰符
internal enum Priority
{
    Low,
    Medium,
    High
}

// 在命名空间中声明
namespace MyProject.Enums
{
    public enum FileType
    {
        Text,
        Image,
        Video,
        Audio
    }
}
```

### 2.2 指定枚举值

```csharp
// 显式指定枚举值
public enum HttpStatusCode
{
    OK = 200,
    NotFound = 404,
    InternalServerError = 500
}

// 混合指定（部分显式，部分自动递增）
public enum ErrorCode
{
    None = 0,
    Warning = 100,
    Error,      // 101
    Critical,   // 102
    Fatal = 500
}

// 使用表达式
public enum Permissions
{
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    ReadWrite = Read | Write,           // 3
    ReadExecute = Read | Execute,       // 5
    WriteExecute = Write | Execute,     // 6
    All = Read | Write | Execute        // 7
}
```

### 2.3 指定基础类型

```csharp
// 默认基础类型是 int
public enum DefaultEnum
{
    Value1, // int 类型
    Value2
}

// 指定不同的基础类型
public enum ByteEnum : byte
{
    Small = 1,
    Medium = 2,
    Large = 3
}

public enum LongEnum : long
{
    VeryLarge = 1000000000000L
}

public enum ShortEnum : short
{
    First = 1,
    Second = 2
}

// 支持的基础类型：byte, sbyte, short, ushort, int, uint, long, ulong
```

## 3. 枚举的使用

### 3.1 基本操作

```csharp
public enum Season
{
    Spring,
    Summer,
    Autumn,
    Winter
}

// 声明和赋值
Season currentSeason = Season.Summer;

// 比较
if (currentSeason == Season.Summer)
{
    Console.WriteLine("现在是夏天");
}

// 类型转换
int seasonValue = (int)currentSeason;
Season convertedSeason = (Season)seasonValue;

// 字符串转换
string seasonName = currentSeason.ToString();
Console.WriteLine(seasonName); // 输出: Summer
```

### 3.2 枚举与字符串的转换

```csharp
public enum Color
{
    Red,
    Green,
    Blue
}

// 枚举转字符串
Color color = Color.Red;
string colorName = color.ToString(); // "Red"

// 字符串转枚举
string input = "Blue";
if (Enum.TryParse<Color>(input, out Color parsedColor))
{
    Console.WriteLine($"解析成功: {parsedColor}");
}
else
{
    Console.WriteLine("解析失败");
}

// 忽略大小写的解析
string input2 = "green";
if (Enum.TryParse<Color>(input2, true, out Color parsedColor2))
{
    Console.WriteLine($"解析成功: {parsedColor2}"); // Green
}

// 使用 Enum.Parse（可能抛出异常）
try
{
    Color color3 = (Color)Enum.Parse(typeof(Color), "Red");
    Console.WriteLine(color3);
}
catch (ArgumentException ex)
{
    Console.WriteLine($"解析失败: {ex.Message}");
}
```

### 3.3 枚举的常用方法

```csharp
public enum Direction
{
    North = 1,
    South = 2,
    East = 4,
    West = 8
}

// 获取所有枚举值
Direction[] allDirections = (Direction[])Enum.GetValues(typeof(Direction));
foreach (Direction dir in allDirections)
{
    Console.WriteLine($"{dir} = {(int)dir}");
}

// 获取所有枚举名称
string[] directionNames = Enum.GetNames(typeof(Direction));
foreach (string name in directionNames)
{
    Console.WriteLine(name);
}

// 检查枚举值是否定义
bool isDefined = Enum.IsDefined(typeof(Direction), "North"); // true
bool isDefined2 = Enum.IsDefined(typeof(Direction), 16);    // false

// 获取枚举的基础类型
Type underlyingType = Enum.GetUnderlyingType(typeof(Direction));
Console.WriteLine(underlyingType); // System.Int32
```

## 4. 标志枚举 (Flags)

### 4.1 Flags 特性

```csharp
[Flags]
public enum FilePermissions
{
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    Delete = 8,
    
    // 组合权限
    ReadWrite = Read | Write,
    ReadExecute = Read | Execute,
    All = Read | Write | Execute | Delete
}

// 使用标志枚举
FilePermissions permissions = FilePermissions.Read | FilePermissions.Write;
Console.WriteLine(permissions); // 输出: Read, Write

// 检查是否包含特定标志
if (permissions.HasFlag(FilePermissions.Read))
{
    Console.WriteLine("具有读权限");
}

// 添加标志
permissions |= FilePermissions.Execute;
Console.WriteLine(permissions); // 输出: Read, Write, Execute

// 移除标志
permissions &= ~FilePermissions.Write;
Console.WriteLine(permissions); // 输出: Read, Execute

// 切换标志
permissions ^= FilePermissions.Delete;
Console.WriteLine(permissions); // 输出: Read, Execute, Delete
```

### 4.2 标志枚举的实际应用

```csharp
[Flags]
public enum LogLevel
{
    None = 0,
    Debug = 1,
    Info = 2,
    Warning = 4,
    Error = 8,
    Critical = 16,
    
    // 预定义组合
    All = Debug | Info | Warning | Error | Critical,
    ErrorsOnly = Error | Critical,
    Verbose = Debug | Info
}

public class Logger
{
    private LogLevel enabledLevels;
    
    public Logger(LogLevel levels)
    {
        enabledLevels = levels;
    }
    
    public void Log(LogLevel level, string message)
    {
        if (enabledLevels.HasFlag(level))
        {
            Console.WriteLine($"[{level}] {DateTime.Now}: {message}");
        }
    }
    
    public void EnableLevel(LogLevel level)
    {
        enabledLevels |= level;
    }
    
    public void DisableLevel(LogLevel level)
    {
        enabledLevels &= ~level;
    }
}

// 使用示例
Logger logger = new Logger(LogLevel.Info | LogLevel.Warning | LogLevel.Error);

logger.Log(LogLevel.Debug, "调试信息");    // 不会输出
logger.Log(LogLevel.Info, "普通信息");     // 会输出
logger.Log(LogLevel.Error, "错误信息");    // 会输出

// 动态调整日志级别
logger.EnableLevel(LogLevel.Debug);
logger.Log(LogLevel.Debug, "现在会输出调试信息"); // 会输出
```

## 5. 枚举的高级用法

### 5.1 枚举扩展方法

```csharp
public enum Priority
{
    Low,
    Medium,
    High,
    Critical
}

public static class PriorityExtensions
{
    public static string GetDescription(this Priority priority)
    {
        return priority switch
        {
            Priority.Low => "低优先级",
            Priority.Medium => "中等优先级",
            Priority.High => "高优先级",
            Priority.Critical => "紧急优先级",
            _ => "未知优先级"
        };
    }
    
    public static ConsoleColor GetColor(this Priority priority)
    {
        return priority switch
        {
            Priority.Low => ConsoleColor.Green,
            Priority.Medium => ConsoleColor.Yellow,
            Priority.High => ConsoleColor.Red,
            Priority.Critical => ConsoleColor.Magenta,
            _ => ConsoleColor.White
        };
    }
    
    public static bool IsUrgent(this Priority priority)
    {
        return priority >= Priority.High;
    }
}

// 使用扩展方法
Priority taskPriority = Priority.Critical;
Console.WriteLine(taskPriority.GetDescription()); // 输出: 紧急优先级
Console.ForegroundColor = taskPriority.GetColor();
Console.WriteLine($"任务优先级: {taskPriority}");

if (taskPriority.IsUrgent())
{
    Console.WriteLine("这是一个紧急任务！");
}
```

### 5.2 使用特性增强枚举

```csharp
using System.ComponentModel;

public enum OrderStatus
{
    [Description("等待处理")]
    Pending,
    
    [Description("正在处理")]
    Processing,
    
    [Description("已完成")]
    Completed,
    
    [Description("已取消")]
    Cancelled
}

public static class EnumExtensions
{
    public static string GetDescription(this Enum value)
    {
        var field = value.GetType().GetField(value.ToString());
        var attribute = field?.GetCustomAttributes(typeof(DescriptionAttribute), false)
                             .FirstOrDefault() as DescriptionAttribute;
        return attribute?.Description ?? value.ToString();
    }
}

// 使用示例
OrderStatus status = OrderStatus.Processing;
Console.WriteLine(status.GetDescription()); // 输出: 正在处理
```

### 5.3 枚举与泛型

```csharp
public static class EnumHelper<T> where T : struct, Enum
{
    public static T[] GetAllValues()
    {
        return (T[])Enum.GetValues(typeof(T));
    }
    
    public static string[] GetAllNames()
    {
        return Enum.GetNames(typeof(T));
    }
    
    public static bool TryParse(string value, out T result)
    {
        return Enum.TryParse<T>(value, true, out result);
    }
    
    public static T GetRandomValue()
    {
        var values = GetAllValues();
        var random = new Random();
        return values[random.Next(values.Length)];
    }
}

// 使用泛型枚举助手
var allColors = EnumHelper<Color>.GetAllValues();
var randomColor = EnumHelper<Color>.GetRandomValue();

if (EnumHelper<Color>.TryParse("red", out Color parsedColor))
{
    Console.WriteLine($"解析成功: {parsedColor}");
}
```

## 6. 枚举的实际应用场景

### 6.1 状态机实现

```csharp
public enum OrderState
{
    Created,
    Paid,
    Shipped,
    Delivered,
    Cancelled
}

public class Order
{
    public int Id { get; set; }
    public OrderState State { get; private set; }
    public DateTime CreatedAt { get; set; }
    
    public Order(int id)
    {
        Id = id;
        State = OrderState.Created;
        CreatedAt = DateTime.Now;
    }
    
    public bool TryTransitionTo(OrderState newState)
    {
        if (IsValidTransition(State, newState))
        {
            State = newState;
            Console.WriteLine($"订单 {Id} 状态变更为: {State}");
            return true;
        }
        
        Console.WriteLine($"无效的状态转换: {State} -> {newState}");
        return false;
    }
    
    private bool IsValidTransition(OrderState from, OrderState to)
    {
        return (from, to) switch
        {
            (OrderState.Created, OrderState.Paid) => true,
            (OrderState.Created, OrderState.Cancelled) => true,
            (OrderState.Paid, OrderState.Shipped) => true,
            (OrderState.Paid, OrderState.Cancelled) => true,
            (OrderState.Shipped, OrderState.Delivered) => true,
            _ => false
        };
    }
}

// 使用状态机
Order order = new Order(1001);
order.TryTransitionTo(OrderState.Paid);      // 成功
order.TryTransitionTo(OrderState.Shipped);   // 成功
order.TryTransitionTo(OrderState.Delivered); // 成功
order.TryTransitionTo(OrderState.Cancelled); // 失败：已交付的订单不能取消
```

### 6.2 配置和选项

```csharp
[Flags]
public enum DatabaseOptions
{
    None = 0,
    EnableLogging = 1,
    EnableCaching = 2,
    EnableCompression = 4,
    EnableEncryption = 8,
    EnableBackup = 16,
    
    // 预设配置
    Development = EnableLogging,
    Production = EnableCaching | EnableCompression | EnableEncryption | EnableBackup,
    Testing = EnableLogging | EnableCaching
}

public class DatabaseConnection
{
    private DatabaseOptions options;
    
    public DatabaseConnection(DatabaseOptions options)
    {
        this.options = options;
        InitializeConnection();
    }
    
    private void InitializeConnection()
    {
        Console.WriteLine("初始化数据库连接...");
        
        if (options.HasFlag(DatabaseOptions.EnableLogging))
        {
            Console.WriteLine("- 启用日志记录");
        }
        
        if (options.HasFlag(DatabaseOptions.EnableCaching))
        {
            Console.WriteLine("- 启用缓存");
        }
        
        if (options.HasFlag(DatabaseOptions.EnableCompression))
        {
            Console.WriteLine("- 启用压缩");
        }
        
        if (options.HasFlag(DatabaseOptions.EnableEncryption))
        {
            Console.WriteLine("- 启用加密");
        }
        
        if (options.HasFlag(DatabaseOptions.EnableBackup))
        {
            Console.WriteLine("- 启用备份");
        }
    }
}

// 使用配置枚举
var devDb = new DatabaseConnection(DatabaseOptions.Development);
var prodDb = new DatabaseConnection(DatabaseOptions.Production);
var customDb = new DatabaseConnection(DatabaseOptions.EnableLogging | DatabaseOptions.EnableCaching);
```

### 6.3 游戏开发中的枚举

```csharp
public enum Direction
{
    North,
    South,
    East,
    West
}

public enum ItemType
{
    Weapon,
    Armor,
    Consumable,
    Quest,
    Misc
}

public enum PlayerClass
{
    Warrior,
    Mage,
    Archer,
    Rogue
}

public static class DirectionExtensions
{
    public static Direction GetOpposite(this Direction direction)
    {
        return direction switch
        {
            Direction.North => Direction.South,
            Direction.South => Direction.North,
            Direction.East => Direction.West,
            Direction.West => Direction.East,
            _ => direction
        };
    }
    
    public static (int x, int y) GetMovement(this Direction direction)
    {
        return direction switch
        {
            Direction.North => (0, -1),
            Direction.South => (0, 1),
            Direction.East => (1, 0),
            Direction.West => (-1, 0),
            _ => (0, 0)
        };
    }
}

public class Player
{
    public string Name { get; set; }
    public PlayerClass Class { get; set; }
    public int X { get; set; }
    public int Y { get; set; }
    
    public void Move(Direction direction)
    {
        var (dx, dy) = direction.GetMovement();
        X += dx;
        Y += dy;
        Console.WriteLine($"{Name} 向 {direction} 移动到 ({X}, {Y})");
    }
}

// 游戏使用示例
Player player = new Player 
{ 
    Name = "英雄", 
    Class = PlayerClass.Warrior, 
    X = 0, 
    Y = 0 
};

player.Move(Direction.North);
player.Move(Direction.East);
Console.WriteLine($"反方向: {Direction.North.GetOpposite()}");
```

## 7. 枚举的最佳实践

### 7.1 命名约定

```csharp
// 好的命名
public enum OrderStatus    // 使用单数形式
{
    Pending,              // 使用描述性名称
    InProgress,           // 使用 PascalCase
    Completed,
    Cancelled
}

// 避免的命名
public enum OrderStatuses  // 避免复数形式
{
    PENDING,              // 避免全大写
    in_progress,          // 避免下划线
    completed1,           // 避免数字后缀
    cancelled
}
```

### 7.2 设计原则

```csharp
// 原则1：为枚举提供明确的零值
public enum ConnectionState
{
    Unknown = 0,    // 明确的默认值
    Connecting,
    Connected,
    Disconnected
}

// 原则2：对于标志枚举，使用2的幂
[Flags]
public enum Permissions
{
    None = 0,
    Read = 1,      // 2^0
    Write = 2,     // 2^1
    Execute = 4,   // 2^2
    Delete = 8     // 2^3
}

// 原则3：考虑未来的扩展性
public enum ApiVersion
{
    V1 = 1,
    V2 = 2,
    V3 = 3,
    // 为未来版本预留空间
    Latest = V3
}
```

### 7.3 性能考虑

```csharp
// 高效的枚举比较
public enum Status { Active, Inactive, Pending }

// 好的做法：直接比较
public bool IsActive(Status status)
{
    return status == Status.Active;  // 高效的值比较
}

// 避免的做法：字符串比较
public bool IsActiveString(Status status)
{
    return status.ToString() == "Active";  // 低效的字符串比较
}

// 缓存枚举值以提高性能
public static class StatusCache
{
    public static readonly Status[] AllStatuses = (Status[])Enum.GetValues(typeof(Status));
    public static readonly string[] AllStatusNames = Enum.GetNames(typeof(Status));
}
```

### 7.4 错误处理

```csharp
public enum Color { Red, Green, Blue }

// 安全的枚举转换
public static bool TryConvertToColor(int value, out Color color)
{
    if (Enum.IsDefined(typeof(Color), value))
    {
        color = (Color)value;
        return true;
    }
    
    color = default;
    return false;
}

// 安全的字符串解析
public static Color ParseColorSafely(string input, Color defaultValue = Color.Red)
{
    if (Enum.TryParse<Color>(input, true, out Color result) && 
        Enum.IsDefined(typeof(Color), result))
    {
        return result;
    }
    
    return defaultValue;
}

// 使用示例
if (TryConvertToColor(1, out Color color))
{
    Console.WriteLine($"转换成功: {color}");
}

Color userColor = ParseColorSafely("purple", Color.Red); // 返回默认值 Red
```

枚举是C#中非常重要的类型，它提供了类型安全、可读性和维护性。正确使用枚举可以让代码更加清晰、健壮和易于维护。掌握枚举的各种用法和最佳实践，是编写高质量C#代码的基础技能之一。